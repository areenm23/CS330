Part1  
------

Q1. If you manually run the testcase#1 without performing any modifications, the OS hangs. Explain why?
	
ans. 	If there is no handler for the divide by zero it is not able to exit from the handler. As there is no do_exit the
	instruction corresponding to div is persisting in the cpu and cpu is repeatdly trying to execute same instruction.

Q2. After building gemOS for testcase#1 (manually), run `objdump -D user/init.o`, examine the assembly for main to 
    find the `idiv' instruction. Apart from the implicit "rax" register, which other register is used? 
    Which registers is used as the numerator and which register as the denominator?

ans. 	rdx and rax have been used for numerator and rcx is used for denominator.


Part 2
------

Q1. After building gemOS for testcase#2 (manually), run `objdump -D user/init.o`, examine the assembly for main to 
    find the `idiv' instruction. What is the length of the `idiv' instruction?

ans. 3 bytes is used for idiv

Q2. Can we use the register over-writing strategy for testcase2? why or why not?

ans. 

Q3. Which memory does the `regs' argument to do_div_by_zero (in hack.c) point to (hint: check the os_rsp value in exec_ctx)?

ans. regs is pointing to the data segment memory. 

Part 3
------

Q1. Why testcase#2 should show the output 'Error...exiting'
ans. Not a valid user handler address is passed to system call.

Part 4
------
Q1. What all registers are changed in do_div_by_zero and why?
ans. entry_rip, entry_rsp has been changed in the system call.

Q2. In testcase #4 and #5, how many times the 'fact' function would return one? 
ans. fact return 1 3 times and 5 times respectively.
